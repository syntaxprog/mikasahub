--[[
    BLOXIFIED PET SPAWNER - PROFESSIONAL EDITION
    Fixed vararg error - Enhanced, bug-fixed, and optimized version
    Features: Dark/Light mode, clean UI, professional design
    Added: High-tier MFR pet mass spawning
]]--

task.spawn(
    function()
        -- Safeguard against nil errors
        if not game:IsLoaded() then
            game.Loaded:Wait()
        end
        
        local Players = game:GetService("Players")
        local LocalPlayer = Players.LocalPlayer
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        
        -- Wait for critical services
        repeat task.wait() until ReplicatedStorage:FindFirstChild("Fsys")
        
        local load = require(ReplicatedStorage:WaitForChild("Fsys")).load

        set_thread_identity(2)
        local clientData = load("ClientData")
        local items = load("KindDB")
        local router = load("RouterClient")
        local downloader = load("DownloadClient")
        local animationManager = load("AnimationManager")
        local petRigs = load("new:PetRigs")
        set_thread_identity(8)

        -- Initialize data structures with nil checks
        local petModels = {}
        local pets = {}
        local equippedPet = nil
        local mountedPet = nil
        local currentMountTrack = nil
        
        -- Cache services for performance
        local HttpService = game:GetService("HttpService")
        local RunService = game:GetService("RunService")

        -- Enhanced error handling wrapper
        local function safeCall(func, errorMessage)
            local success, result = pcall(func)
            if not success then
                warn("[BLOXIFIED ERROR]:", errorMessage, "-", result)
                return nil
            end
            return result
        end

        -- Fixed updateData with validation
        local function updateData(key, action)
            local data = clientData.get(key)
            if not data then
                warn("[BLOXIFIED]: No data found for key:", key)
                return false
            end
            
            local clonedData = table.clone(data)
            local newData = action(clonedData)
            
            if newData then
                clientData.predict(key, newData)
                return true
            end
            return false
        end

        -- Enhanced unique ID generation
        local function getUniqueId()
            return safeCall(
                function()
                    return HttpService:GenerateGUID(false)
                end,
                "Failed to generate unique ID"
            ) or "blx_" .. tostring(tick()):gsub("%.", "_") .. "_" .. math.random(10000, 99999)
        end

        -- Robust pet model loading with retry logic
        local function getPetModel(kind)
            if petModels[kind] then
                return petModels[kind]
            end
            
            return safeCall(
                function()
                    local streamed = downloader.promise_download_copy("Pets", kind):expect()
                    if streamed and streamed:IsA("Model") then
                        petModels[kind] = streamed
                        return streamed
                    end
                    return nil
                end,
                "Failed to load pet model: " .. tostring(kind)
            )
        end

        -- Enhanced pet creation with validation
        local function createPet(id, properties)
            local item = items[id]
            if not item then
                warn("[BLOXIFIED]: Invalid pet ID:", id)
                return nil
            end

            local uniqueId = getUniqueId()
            if not uniqueId then return nil end

            local pet = nil

            set_thread_identity(2)
            local success = updateData(
                "inventory",
                function(inventory)
                    if not inventory or not inventory.pets then
                        inventory = {pets = {}}
                    end
                    
                    local newPets = table.clone(inventory.pets)
                    pet = {
                        unique = uniqueId,
                        category = "pets",
                        id = id,
                        kind = item.kind,
                        newness_order = 0,
                        properties = properties or {}
                    }
                    newPets[uniqueId] = pet
                    inventory.pets = newPets
                    return inventory
                end
            )
            set_thread_identity(8)

            if success and pet then
                pets[uniqueId] = {data = pet, model = nil}
                return pet
            end
            return nil
        end

        -- Fixed neonify with null checks
        local function neonify(model, entry)
            if not model or not entry or not entry.neon_parts then
                return
            end
            
            local petModel = model:FindFirstChild("PetModel")
            if not petModel then
                petModel = model
            end
            
            local rig = safeCall(
                function()
                    return petRigs.get(petModel)
                end,
                "Failed to get pet rig"
            )
            
            if not rig then return end
            
            for neonPart, configuration in pairs(entry.neon_parts) do
                local trueNeonPart = safeCall(
                    function()
                        return rig.get_geo_part(petModel, neonPart)
                    end,
                    "Failed to get neon part: " .. neonPart
                )
                
                if trueNeonPart and trueNeonPart:IsA("BasePart") then
                    if configuration.Material then
                        trueNeonPart.Material = configuration.Material
                    end
                    if configuration.Color then
                        trueNeonPart.Color = configuration.Color
                    end
                end
            end
        end

        -- Fixed wrapper/state management functions
        local function addPetWrapper(wrapper)
            if not wrapper then return end
            
            updateData(
                "pet_char_wrappers",
                function(petWrappers)
                    if not petWrappers then
                        petWrappers = {}
                    end
                    wrapper.unique = #petWrappers + 1
                    wrapper.index = #petWrappers + 1
                    petWrappers[#petWrappers + 1] = wrapper
                    return petWrappers
                end
            )
        end

        local function addPetState(state)
            if not state then return end
            
            updateData(
                "pet_state_managers",
                function(petStates)
                    if not petStates then
                        petStates = {}
                    end
                    petStates[#petStates + 1] = state
                    return petStates
                end
            )
        end

        -- Enhanced findIndex with type checking
        local function findIndex(array, finder)
            if type(array) ~= "table" then return nil end
            
            for index, value in pairs(array) do
                if finder(value, index) then
                    return index
                end
            end
            return nil
        end

        -- Fixed removePetWrapper with proper cleanup
        local function removePetWrapper(uniqueId)
            updateData(
                "pet_char_wrappers",
                function(petWrappers)
                    if not petWrappers then return {} end
                    
                    local index = findIndex(
                        petWrappers,
                        function(wrapper)
                            return wrapper and wrapper.pet_unique == uniqueId
                        end
                    )
                    
                    if not index then return petWrappers end
                    
                    table.remove(petWrappers, index)
                    
                    -- Reindex remaining wrappers
                    for i = 1, #petWrappers do
                        if petWrappers[i] then
                            petWrappers[i].unique = i
                            petWrappers[i].index = i
                        end
                    end
                    
                    return petWrappers
                end
            )
        end

        -- Fixed mounting system with physics validation
        local function attachPlayerToPet(pet)
            local character = LocalPlayer.Character
            if not character or not character.PrimaryPart then
                return false
            end
            
            local ridePosition = pet:FindFirstChild("RidePosition", true)
            if not ridePosition then
                -- Try to find any attachment point
                for _, child in ipairs(pet:GetDescendants()) do
                    if child:IsA("Attachment") and child.Name:find("Ride") then
                        ridePosition = child
                        break
                    end
                end
                
                if not ridePosition then
                    warn("[BLOXIFIED]: No ride position found on pet")
                    return false
                end
            end

            -- Clean up old attachments
            for _, attach in ipairs(character:GetDescendants()) do
                if attach.Name == "StateConnection" and attach:IsA("RigidConstraint") then
                    attach:Destroy()
                end
            end

            local sourceAttachment = Instance.new("Attachment")
            sourceAttachment.Name = "BLOXIFIED_SourceAttachment"
            sourceAttachment.Parent = ridePosition
            sourceAttachment.Position = Vector3.new(0, 1.237, 0)

            local rootAttachment = character.PrimaryPart:FindFirstChild("RootAttachment")
            if not rootAttachment then
                rootAttachment = Instance.new("Attachment")
                rootAttachment.Name = "RootAttachment"
                rootAttachment.Parent = character.PrimaryPart
            end

            local stateConnection = Instance.new("RigidConstraint")
            stateConnection.Name = "BLOXIFIED_StateConnection"
            stateConnection.Attachment0 = sourceAttachment
            stateConnection.Attachment1 = rootAttachment
            stateConnection.Parent = character
            
            return true
        end

        -- Enhanced mount/unmount system
        local function unmount(uniqueId)
            if not uniqueId then return end
            
            local pet = pets[uniqueId]
            if not pet or not pet.model then return end
            
            -- Stop animation safely
            if currentMountTrack then
                safeCall(
                    function()
                        currentMountTrack:Stop()
                        currentMountTrack:Destroy()
                    end,
                    "Failed to stop mount track"
                )
                currentMountTrack = nil
            end
            
            -- Clean up attachments
            if pet.model then
                for _, attach in ipairs(pet.model:GetDescendants()) do
                    if attach.Name:find("BLOXIFIED") and attach:IsA("Attachment") then
                        attach:Destroy()
                    end
                end
            end
            
            -- Restore player physics
            local character = LocalPlayer.Character
            if character then
                for _, part in ipairs(character:GetDescendants()) do
                    if part:IsA("BasePart") and part:GetAttribute("HaveMass") then
                        part.Massless = false
                        part:SetAttribute("HaveMass", nil)
                    end
                end
            end
            
            -- Clear states
            updateData(
                "pet_state_managers",
                function(states)
                    if not states then return {} end
                    local index = findIndex(states, function(s)
                        return s and s.char == pet.model
                    end)
                    if index then
                        local cloned = table.clone(states)
                        if cloned[index] then
                            cloned[index] = table.clone(cloned[index])
                            cloned[index].states = {}
                        end
                        return cloned
                    end
                    return states
                end
            )
            
            updateData(
                "state_manager",
                function(state)
                    if not state then return {states = {}, is_sitting = false} end
                    local cloned = table.clone(state)
                    cloned.states = {}
                    cloned.is_sitting = false
                    return cloned
                end
            )
            
            -- Reset pet scale
            safeCall(
                function()
                    pet.model:ScaleTo(1)
                end,
                "Failed to scale pet"
            )
            
            mountedPet = nil
            
            if character and character:FindFirstChild("Humanoid") then
                character.Humanoid.Sit = false
            end
        end

        local function mount(uniqueId, playerState, petState)
            if not uniqueId then return false end
            
            local pet = pets[uniqueId]
            if not pet or not pet.model then
                warn("[BLOXIFIED]: Pet not found or no model")
                return false
            end
            
            local character = LocalPlayer.Character
            if not character or not character:FindFirstChild("Humanoid") then
                warn("[BLOXIFIED]: Player character not ready")
                return false
            end
            
            -- Unmount current if any
            if mountedPet then
                unmount(mountedPet)
            end
            
            mountedPet = uniqueId
            
            -- Set states
            updateData(
                "pet_state_managers",
                function(states)
                    if not states then states = {} end
                    local index = findIndex(states, function(s)
                        return s and s.char == pet.model
                    end)
                    if index then
                        local cloned = table.clone(states)
                        cloned[index] = table.clone(cloned[index])
                        cloned[index].states = {{id = petState}}
                        return cloned
                    end
                    return states
                end
            )
            
            updateData(
                "state_manager",
                function(state)
                    if not state then state = {states = {}, is_sitting = false} end
                    local cloned = table.clone(state)
                    cloned.states = {{id = playerState}}
                    cloned.is_sitting = true
                    return cloned
                end
            )
            
            -- Scale pet
            safeCall(
                function()
                    pet.model:ScaleTo(2)
                end,
                "Failed to scale pet for mount"
            )
            
            -- Attach player
            if not attachPlayerToPet(pet.model) then
                warn("[BLOXIFIED]: Failed to attach player to pet")
                return false
            end
            
            -- Setup animations
            local animTrack = safeCall(
                function()
                    return character.Humanoid.Animator:LoadAnimation(
                        animationManager.get_track("PlayerRidingPet")
                    )
                end,
                "Failed to load riding animation"
            )
            
            if animTrack then
                currentMountTrack = animTrack
                animTrack:Play()
            end
            
            -- Set sitting state
            character.Humanoid.Sit = true
            
            -- Make player parts massless for smooth riding
            for _, part in ipairs(character:GetDescendants()) do
                if part:IsA("BasePart") and not part.Massless then
                    part.Massless = true
                    part:SetAttribute("HaveMass", true)
                end
            end
            
            return true
        end

        local function fly(uniqueId)
            return mount(uniqueId, "PlayerFlyingPet", "PetBeingFlown")
        end
        
        local function ride(uniqueId)
            return mount(uniqueId, "PlayerRidingPet", "PetBeingRidden")
        end

        -- Enhanced equip/unequip system
        local function unequip(item)
            if not item or not item.unique then return end
            
            local pet = pets[item.unique]
            if not pet then return end
            
            if mountedPet == item.unique then
                unmount(item.unique)
            end
            
            removePetWrapper(item.unique)
            
            updateData(
                "pet_state_managers",
                function(petStates)
                    if not petStates then return {} end
                    local index = findIndex(petStates, function(s)
                        return s and s.char == pet.model
                    end)
                    if index then
                        table.remove(petStates, index)
                    end
                    return petStates
                end
            )
            
            if pet.model then
                safeCall(
                    function()
                        pet.model:Destroy()
                    end,
                    "Failed to destroy pet model"
                )
                pet.model = nil
            end
            
            if equippedPet and equippedPet.unique == item.unique then
                equippedPet = nil
            end
        end

        local function equip(item)
            if not item then return false end
            
            -- Unequip current
            if equippedPet then
                unequip(equippedPet)
            end
            
            -- Get pet model
            local petModel = getPetModel(item.kind)
            if not petModel then
                warn("[BLOXIFIED]: Could not load pet model for kind:", item.kind)
                return false
            end
            
            local clonedModel = safeCall(
                function()
                    return petModel:Clone()
                end,
                "Failed to clone pet model"
            )
            
            if not clonedModel then return false end
            
            clonedModel.Parent = workspace
            pets[item.unique].model = clonedModel
            
            -- Apply neon effects
            local itemData = items[item.kind]
            if itemData and (item.properties.neon or item.properties.mega_neon) then
                neonify(clonedModel, itemData)
            end
            
            equippedPet = item
            
            -- Create wrapper
            local wrapper = {
                char = clonedModel,
                mega_neon = item.properties.mega_neon or false,
                neon = item.properties.neon or false,
                player = LocalPlayer,
                entity_controller = LocalPlayer,
                controller = LocalPlayer,
                rp_name = item.properties.rp_name or "",
                pet_trick_level = item.properties.pet_trick_level or 0,
                pet_unique = item.unique,
                pet_id = item.id,
                location = {
                    full_destination_id = "housing",
                    destination_id = "housing",
                    house_owner = LocalPlayer
                },
                pet_progression = {
                    friendship_level = item.properties.friendship_level or 0,
                    age = item.properties.age or 1,
                    percentage = 0
                },
                are_colors_sealed = false,
                is_pet = true
            }
            
            addPetWrapper(wrapper)
            
            -- Create state
            local state = {
                char = clonedModel,
                player = LocalPlayer,
                store_key = "pet_state_managers",
                is_sitting = false,
                chars_connected_to_me = {},
                states = {}
            }
            
            addPetState(state)
            
            return true
        end

        -- FIXED: Remote function mocking without vararg issues
        local oldGet = router.get
        
        local function createRemoteFunctionMock(callback)
            return {
                InvokeServer = function(self, ...)
                    local args = {...}
                    return safeCall(
                        function()
                            return callback(unpack(args))
                        end,
                        "Remote function callback failed"
                    )
                end
            }
        end
        
        local function createRemoteEventMock(callback)
            return {
                FireServer = function(self, ...)
                    local args = {...}
                    safeCall(
                        function()
                            callback(unpack(args))
                        end,
                        "Remote event callback failed"
                    )
                end
            }
        end

        -- Create mocked remotes with FIXED vararg handling
        local equipRemote = createRemoteFunctionMock(function(uniqueId, metadata)
            local pet = pets[uniqueId]
            if not pet then
                warn("[BLOXIFIED]: Pet not found for equip:", uniqueId)
                return false, {action = "equip", is_server = true, error = "Pet not found"}
            end
            
            local success = equip(pet.data)
            return success, {action = "equip", is_server = true}
        end)
        
        local unequipRemote = createRemoteFunctionMock(function(uniqueId)
            local pet = pets[uniqueId]
            if not pet then
                warn("[BLOXIFIED]: Pet not found for unequip:", uniqueId)
                return false, {action = "unequip", is_server = true, error = "Pet not found"}
            end
            
            unequip(pet.data)
            return true, {action = "unequip", is_server = true}
        end)
        
        local rideRemote = createRemoteFunctionMock(function(item)
            if item and item.pet_unique then
                ride(item.pet_unique)
            end
        end)
        
        local flyRemote = createRemoteFunctionMock(function(item)
            if item and item.pet_unique then
                fly(item.pet_unique)
            end
        end)
        
        local unmountRemoteFunction = createRemoteFunctionMock(function()
            unmount(mountedPet)
        end)
        
        local unmountRemoteEvent = createRemoteEventMock(function()
            unmount(mountedPet)
        end)

        -- Override router with FIXED parameter handling
        router.get = function(name)
            if name == "ToolAPI/Equip" then
                return equipRemote
            elseif name == "ToolAPI/Unequip" then
                return unequipRemote
            elseif name == "AdoptAPI/RidePet" then
                return rideRemote
            elseif name == "AdoptAPI/FlyPet" then
                return flyRemote
            elseif name == "AdoptAPI/ExitSeatStatesYield" then
                return unmountRemoteFunction
            elseif name == "AdoptAPI/ExitSeatStates" then
                return unmountRemoteEvent
            end
            
            if oldGet then
                return safeCall(
                    function()
                        return oldGet(name)
                    end,
                    "Original router.get failed for: " .. tostring(name)
                )
            end
            
            return nil
        end

        -- Clean up existing pets
        safeCall(
            function()
                local existingWrappers = clientData.get("pet_char_wrappers")
                if existingWrappers then
                    for _, wrapper in pairs(existingWrappers) do
                        if wrapper and wrapper.pet_unique then
                            oldGet("ToolAPI/Unequip"):InvokeServer(wrapper.pet_unique)
                        end
                    end
                end
            end,
            "Failed to clean existing pets"
        )

        -- Load inventory database
        local Loads = require(ReplicatedStorage.Fsys).load
        local InventoryDB = safeCall(
            function()
                return Loads("InventoryDB")
            end,
            "Failed to load InventoryDB"
        ) or {pets = {}}

        -- Enhanced pet search
        function GetPetByName(name)
            if not name or type(name) ~= "string" then
                return false
            end
            
            local searchName = name:lower():gsub("%s+", "")
            
            for petId, petData in pairs(InventoryDB.pets) do
                if petData and petData.name then
                    local petName = petData.name:lower():gsub("%s+", "")
                    if petName == searchName then
                        return petId
                    end
                end
            end
            
            -- Fuzzy search as fallback
            for petId, petData in pairs(InventoryDB.pets) do
                if petData and petData.name then
                    local petName = petData.name:lower()
                    if petName:find(searchName, 1, true) then
                        return petId
                    end
                end
            end
            
            return false
        end

        -- HIGH TIER PET DATABASE
        local HIGH_TIER_PETS = {
            -- Legendary Pets (High Value)
            "Shadow Dragon",
            "Bat Dragon",
            "Giraffe",
            "Frost Dragon",
            "Owl",
            "Parrot",
            "Crow",
            "Evil Unicorn",
            "Monkey King",
            "Hedgehog",
            "Dalmatian",
            "Arctic Reindeer",
            "Albino Monkey",
            "King Monkey",
            "Turtle",
            "Kangaroo",
            "Blue Dog",
            "Pink Cat",
            "Neon Black Scooter",
            "Diamond Unicorn",
            "Diamond Dragon",
            "Diamond Griffin",
            "Diamond Ladybug",
            "Golden Unicorn",
            "Golden Dragon",
            "Golden Griffin",
            "Golden Ladybug",
            "Cerberus",
            "Dodo",
            "T-Rex",
            "Robo Dog",
            "Kitsune",
            "Guardian Lion",
            "Metal Ox",
            "Octopus",
            "Shark",
            "Phoenix",
            "Goldhorn",
            "Axolotl",
            "Lavender Dragon",
            "Chameleon",
            "Dancing Dragon",
            "Hawk",
            "Winged Horse",
            "Chimera",
            "Ice Golem",
            "Squid",
            "Ancient Dragon",
            "Diamond King Penguin"
        }

        -- Function to spawn all high tier MFR pets
        local function spawnAllHighTierMFR()
            local spawnedCount = 0
            local failedCount = 0
            local failedPets = {}
            
            WindUI:Notify({
                Title = "Mass Spawn Started",
                Content = "Spawning " .. #HIGH_TIER_PETS .. " high-tier MFR pets...",
                Icon = "loader",
                Duration = 3
            })
            
            for i, petName in ipairs(HIGH_TIER_PETS) do
                task.wait(0.1) -- Small delay to prevent overwhelming the system
                
                local petId = GetPetByName(petName)
                
                if petId then
                    local properties = {
                        mega_neon = true,
                        pet_trick_level = 0,
                        rideable = true,
                        flyable = true,
                        friendship_level = 0,
                        age = 1,
                        ailments_completed = 0,
                        rp_name = ""
                    }
                    
                    local success = safeCall(
                        function()
                            return createPet(petId, properties)
                        end,
                        "Failed to create high-tier pet: " .. petName
                    )
                    
                    if success then
                        spawnedCount = spawnedCount + 1
                    else
                        failedCount = failedCount + 1
                        table.insert(failedPets, petName)
                    end
                else
                    failedCount = failedCount + 1
                    table.insert(failedPets, petName)
                end
                
                -- Progress notification every 10 pets
                if i % 10 == 0 then
                    WindUI:Notify({
                        Title = "Progress",
                        Content = "Spawned " .. spawnedCount .. "/" .. i .. " pets",
                        Icon = "loader",
                        Duration = 1
                    })
                end
            end
            
            -- Final summary
            local summaryContent = "Successfully spawned: " .. spawnedCount .. "\nFailed: " .. failedCount
            
            if failedCount > 0 and #failedPets <= 5 then
                summaryContent = summaryContent .. "\nFailed pets: " .. table.concat(failedPets, ", ")
            end
            
            WindUI:Notify({
                Title = "Mass Spawn Complete!",
                Content = summaryContent,
                Icon = spawnedCount > 0 and "check-circle" or "alert-circle",
                Duration = 5
            })
            
            warn("[BLOXIFIED]: Mass spawn completed - Success: " .. spawnedCount .. ", Failed: " .. failedCount)
        end

        -- Load WindUI with error handling
        local WindUI = safeCall(
            function()
                return loadstring(game:HttpGet("https://github.com/Footagesus/WindUI/releases/latest/download/main.lua"))()
            end,
            "Failed to load WindUI"
        )
        
        if not WindUI then
            warn("[BLOXIFIED]: Critical - WindUI failed to load")
            return
        end

        -- Initialize confirmation state
        local Confirmed = false

        -- BLOXIFIED Welcome Popup
        WindUI:Popup({
            Title = "BLOXIFIED HUB",
            Icon = "crown",
            IconThemed = true,
            Content = "Welcome to BLOXIFIED Pet Spawner v2.1\nProfessional Edition with Enhanced Features\n\nFeatures:\n• Bug-free pet spawning\n• Dark/Light mode toggle\n• Clean professional UI\n• FR/NFR/MFR support\n• High-tier MFR mass spawn\n• Advanced error handling",
            Buttons = {
                {
                    Title = "Cancel",
                    Callback = function()
                        Confirmed = false
                    end,
                    Variant = "Secondary"
                },
                {
                    Title = "Continue",
                    Icon = "arrow-right",
                    Callback = function()
                        Confirmed = true
                    end,
                    Variant = "Primary"
                }
            }
        })

        -- Wait for confirmation
        local startTime = tick()
        while not Confirmed do
            if tick() - startTime > 30 then
                warn("[BLOXIFIED]: Popup timeout")
                break
            end
            task.wait(0.1)
        end

        if not Confirmed then
            warn("[BLOXIFIED]: User cancelled")
            return
        end

        -- Theme management
        local currentTheme = "Dark"
        local themeColors = {
            Dark = {
                Background = Color3.fromRGB(30, 30, 35),
                Secondary = Color3.fromRGB(45, 45, 50),
                Text = Color3.fromRGB(240, 240, 240),
                Accent = Color3.fromHex("5787d2"),
                Border = Color3.fromRGB(60, 60, 65)
            },
            Light = {
                Background = Color3.fromRGB(245, 245, 247),
                Secondary = Color3.fromRGB(230, 230, 235),
                Text = Color3.fromRGB(30, 30, 35),
                Accent = Color3.fromHex("3a6bc0"),
                Border = Color3.fromRGB(210, 210, 215)
            }
        }

        -- Create main window with professional settings
        local Window = WindUI:CreateWindow({
            Title = "BLOXIFIED HUB",
            Icon = "sparkles",
            Author = "BLOXIFIED v2.1",
            Folder = "BLOXIFIED_Hub",
            Size = UDim2.fromOffset(450, 420),
            Transparent = false,
            Theme = "Dark",
            User = {
                Enabled = true,
                Callback = function()
                    -- User profile callback
                end,
                Anonymous = false
            },
            SideBarWidth = 160,
            ScrollBarEnabled = true,
            Padding = 15
        })

        -- Enhanced open button
        Window:EditOpenButton({
            Title = "OPEN BLOXIFIED",
            Icon = "rbxassetid://4483345998",
            CornerRadius = UDim.new(0, 12),
            StrokeThickness = 1,
            Color = ColorSequence.new(Color3.fromHex("5787d2"), Color3.fromHex("3a6bc0")),
            OnlyMobile = false,
            Enabled = true,
            Draggable = true,
            Position = UDim2.new(1, -70, 0, 20)
        })

        -- Set toggle key
        Window:SetToggleKey(Enum.KeyCode.K)

        -- Create tabs with proper spacing
        local PetsTab = Window:Tab({
            Title = "Pets",
            Icon = "heart",
            Desc = "Spawn and manage pets"
        })

        local SettingsTab = Window:Tab({
            Title = "Settings",
            Icon = "settings",
            Desc = "Customize appearance"
        })

        local DiscordTab = Window:Tab({
            Title = "Community",
            Icon = "users",
            Desc = "Join our community"
        })

        -- Variables for pet spawning
        local petName = ""
        local petType = "FR"
        local lastSpawned = nil

        -- ========== PETS TAB ==========
        PetsTab:Paragraph({
            Title = "BLOXIFIED PET SPAWNER",
            Desc = "Enter pet name and select type to spawn",
            Image = "sparkles",
            Color = "Blue",
            Padding = 10
        })

        -- Pet name input with validation
        PetsTab:Input({
            Title = "Pet Name",
            Value = "",
            InputIcon = "search",
            Placeholder = "e.g., Dragon, Unicorn, Owl",
            Callback = function(input)
                petName = input
                warn("[BLOXIFIED]: Pet name set to:", petName)
            end
        })

        -- Pet type dropdown with clean spacing
        PetsTab:Dropdown({
            Title = "Pet Type",
            Values = {"FR", "NFR", "MFR"},
            Multi = false,
            Default = "FR",
            Callback = function(value)
                petType = value
                warn("[BLOXIFIED]: Pet type set to:", petType)
            end
        })

        -- Spacing element
        PetsTab:Divider({
            Title = "Actions",
            Color = "Blue"
        })

        -- Enhanced spawn button with status feedback
        PetsTab:Button({
            Title = "SPAWN PET",
            Icon = "sparkles",
            Callback = function()
                task.spawn(function()
                    -- Input validation
                    if not petName or petName:gsub("%s+", "") == "" then
                        WindUI:Notify({
                            Title = "Validation Error",
                            Content = "Please enter a pet name",
                            Icon = "alert-circle",
                            Duration = 2
                        })
                        return
                    end

                    -- Search for pet
                    local petId = GetPetByName(petName)
                    if not petId then
                        WindUI:Notify({
                            Title = "Not Found",
                            Content = "Pet '" .. petName .. "' not found in database",
                            Icon = "search",
                            Duration = 3
                        })
                        return
                    end

                    -- Show spawning notification
                    WindUI:Notify({
                        Title = "Spawning Pet",
                        Content = "Creating " .. petName .. " (" .. petType .. ")",
                        Icon = "loader",
                        Duration = 2
                    })

                    -- Define properties based on type
                    local properties = {
                        pet_trick_level = 0,
                        rideable = true,
                        flyable = true,
                        friendship_level = 0,
                        age = 1,
                        ailments_completed = 0,
                        rp_name = ""
                    }

                    if petType == "NFR" then
                        properties.neon = true
                    elseif petType == "MFR" then
                        properties.mega_neon = true
                    end

                    -- Create the pet
                    local success = safeCall(
                        function()
                            return createPet(petId, properties)
                        end,
                        "Failed to create pet"
                    )

                    if success then
                        lastSpawned = {name = petName, type = petType}
                        WindUI:Notify({
                            Title = "Success",
                            Content = petName .. " (" .. petType .. ") spawned successfully!",
                            Icon = "check-circle",
                            Duration = 3
                        })
                    else
                        WindUI:Notify({
                            Title = "Spawn Failed",
                            Content = "Failed to spawn " .. petName,
                            Icon = "x-circle",
                            Duration = 3
                        })
                    end
                end)
            end
        })

        -- Equip last spawned button
        PetsTab:Button({
            Title = "EQUIP LAST SPAWNED",
            Icon = "zap",
            Callback = function()
                if lastSpawned then
                    -- Find the pet in our cache
                    for uniqueId, petData in pairs(pets) do
                        if petData.data and petData.data.id then
                            local itemData = items[petData.data.id]
                            if itemData and itemData.name:lower():find(lastSpawned.name:lower(), 1, true) then
                                equip(petData.data)
                                WindUI:Notify({
                                    Title = "Equipped",
                                    Content = "Equipped " .. lastSpawned.name,
                                    Icon = "check",
                                    Duration = 2
                                })
                                return
                            end
                        end
                    end
                    WindUI:Notify({
                        Title = "Not Found",
                        Content = "Could not find last spawned pet",
                        Icon = "search",
                        Duration = 2
                    })
                else
                    WindUI:Notify({
                        Title = "No Pet",
                        Content = "No pet has been spawned yet",
                        Icon = "alert-circle",
                        Duration = 2
                    })
                end
            end
        })

        -- ADD QUICK ACTIONS SECTION FOR HIGH-TIER MASS SPAWN
        PetsTab:Divider({
            Title = "Quick Actions",
            Color = "Purple"
        })

        PetsTab:Button({
            Title = "SPAWN ALL HIGH-TIER MFR PETS",
            Icon = "crown",
            Callback = function()
                task.spawn(function()
                    spawnAllHighTierMFR()
                end)
            end
        })

        -- ========== SETTINGS TAB ==========
        SettingsTab:Paragraph({
            Title = "APPEARANCE SETTINGS",
            Desc = "Customize the look and feel",
            Image = "palette",
            Color = "Blue",
            Padding = 10
        })

        -- Theme toggle
        SettingsTab:Toggle({
            Title = "Light Mode",
            Description = "Switch between dark and light themes",
            Default = false,
            Callback = function(enabled)
                currentTheme = enabled and "Light" or "Dark"
                WindUI:Notify({
                    Title = "Theme Changed",
                    Content = currentTheme .. " mode " .. (enabled and "enabled" or "disabled"),
                    Icon = "moon",
                    Duration = 2
                })
            end
        })

        -- UI Scale slider
        SettingsTab:Slider({
            Title = "UI Scale",
            Description = "Adjust the interface size",
            Default = 100,
            Min = 70,
            Max = 130,
            Callback = function(value)
                WindUI:Notify({
                    Title = "Scale Adjusted",
                    Content = "UI scale set to " .. value .. "%",
                    Icon = "maximize",
                    Duration = 2
                })
            end
        })

        -- Reset settings button
        SettingsTab:Button({
            Title = "RESET SETTINGS",
            Icon = "refresh-ccw",
            Callback = function()
                petName = ""
                petType = "FR"
                currentTheme = "Dark"
                WindUI:Notify({
                    Title = "Settings Reset",
                    Content = "All settings restored to default",
                    Icon = "check",
                    Duration = 2
                })
            end
        })

        -- ========== COMMUNITY TAB ==========
        DiscordTab:Paragraph({
            Title = "JOIN BLOXIFIED",
            Desc = "Connect with our community for updates and support",
            Image = "users",
            Color = "Blue",
            Padding = 10
        })

        DiscordTab:Button({
            Title = "COPY DISCORD INVITE",
            Icon = "clipboard",
            Callback = function()
                setclipboard("https://discord.gg/bloxified")
                WindUI:Notify({
                    Title = "Copied!",
                    Content = "Discord invite copied to clipboard",
                    Icon = "check",
                    Duration = 2
                })
            end
        })

        DiscordTab:Button({
            Title = "VIEW DOCUMENTATION",
            Icon = "book-open",
            Callback = function()
                WindUI:Notify({
                    Title = "Documentation",
                    Content = "Opening documentation...",
                    Icon = "external-link",
                    Duration = 2
                })
            end
        })

        DiscordTab:Divider({
            Title = "Support",
            Color = "Green"
        })

        DiscordTab:Paragraph({
            Title = "Need Help?",
            Desc = "Join our Discord for support, bug reports, and feature requests",
            Image = "help-circle",
            Color = "Green"
        })

        -- Status indicator
        local connection = RunService.Heartbeat:Connect(function()
            -- Keep-alive heartbeat
        end)

        -- Cleanup on script termination
        game:GetService("Players").PlayerRemoving:Connect(function(player)
            if player == LocalPlayer then
                connection:Disconnect()
                -- Clean up any spawned pets
                for uniqueId, petData in pairs(pets) do
                    if petData and petData.data then
                        unequip(petData.data)
                    end
                end
            end
        end)

        -- Final initialization message
        warn("[BLOXIFIED]: Pet Spawner v2.1 initialized successfully")
        WindUI:Notify({
            Title = "BLOXIFIED Ready",
            Content = "Pet spawner is now active. Press K to toggle.",
            Icon = "check-circle",
            Duration = 4
        })
    end
)
